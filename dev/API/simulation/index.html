<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model-specific functions ¬∑ NeuralEstimators.jl</title><meta name="title" content="Model-specific functions ¬∑ NeuralEstimators.jl"/><meta property="og:title" content="Model-specific functions ¬∑ NeuralEstimators.jl"/><meta property="twitter:title" content="Model-specific functions ¬∑ NeuralEstimators.jl"/><meta name="description" content="Documentation for NeuralEstimators.jl."/><meta property="og:description" content="Documentation for NeuralEstimators.jl."/><meta property="twitter:description" content="Documentation for NeuralEstimators.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NeuralEstimators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NeuralEstimators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NeuralEstimators</a></li><li><a class="tocitem" href="../../methodology/">Methodology</a></li><li><span class="tocitem">Workflow</span><ul><li><a class="tocitem" href="../../workflow/overview/">Overview</a></li><li><a class="tocitem" href="../../workflow/examples/">Examples</a></li><li><a class="tocitem" href="../../workflow/advancedusage/">Advanced usage</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../core/">Core</a></li><li><a class="tocitem" href="../architectures/">Architectures</a></li><li><a class="tocitem" href="../approximatedistributions/">Approximate distributions</a></li><li><a class="tocitem" href="../loss/">Loss functions</a></li><li class="is-active"><a class="tocitem" href>Model-specific functions</a><ul class="internal"><li><a class="tocitem" href="#Data-simulators"><span>Data simulators</span></a></li><li><a class="tocitem" href="#Spatial-point-processes"><span>Spatial point processes</span></a></li><li><a class="tocitem" href="#Covariance-functions"><span>Covariance functions</span></a></li><li><a class="tocitem" href="#Density-functions"><span>Density functions</span></a></li></ul></li><li><a class="tocitem" href="../utility/">Miscellaneous</a></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Model-specific functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model-specific functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/msainsburydale/NeuralEstimators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/main/docs/src/API/simulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-specific-functions"><a class="docs-heading-anchor" href="#Model-specific-functions">Model-specific functions</a><a id="Model-specific-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Model-specific-functions" title="Permalink"></a></h1><h2 id="Data-simulators"><a class="docs-heading-anchor" href="#Data-simulators">Data simulators</a><a id="Data-simulators-1"></a><a class="docs-heading-anchor-permalink" href="#Data-simulators" title="Permalink"></a></h2><p>The philosophy of <code>NeuralEstimators</code> is to cater for any model for which simulation is feasible by allowing users to define their model implicitly through simulated data. However, the following functions have been included as they may be helpful to others, and their source code illustrates how a user could formulate code for their own model.</p><p>See also <a href="https://juliastats.org/Distributions.jl/stable/">Distributions.jl</a> for a range of distributions implemented in Julia, and the package <a href="https://juliainterop.github.io/RCall.jl/stable/">RCall</a> for calling R functions within Julia. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.simulategaussian" href="#NeuralEstimators.simulategaussian"><code>NeuralEstimators.simulategaussian</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulategaussian(L::AbstractMatrix, m = 1)</code></pre><p>Simulates <code>m</code> independent and identically distributed realisations from a mean-zero multivariate Gaussian random vector with associated lower Cholesky  factor <code>L</code>. </p><p>If <code>m</code> is not specified, the simulated data are returned as a vector with length equal to the number of spatial locations, <span>$n$</span>; otherwise, the data are returned as an <span>$n$</span>x<code>m</code> matrix.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators, Distances, LinearAlgebra

n = 500
œÅ = 0.6
ŒΩ = 1.0
S = rand(n, 2)
D = pairwise(Euclidean(), S, dims = 1)
Œ£ = Symmetric(matern.(D, œÅ, ŒΩ))
L = cholesky(Œ£).L
simulategaussian(L)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/simulate.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.simulatepotts" href="#NeuralEstimators.simulatepotts"><code>NeuralEstimators.simulatepotts</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulatepotts(grid::Matrix{Int}, Œ≤)
simulatepotts(grid::Matrix{Union{Int, Nothing}}, Œ≤)
simulatepotts(nrows::Int, ncols::Int, num_states::Int, Œ≤)</code></pre><p>Chequerboard Gibbs sampling from a spatial Potts model with parameter <code>Œ≤</code>&gt;0 (see, e.g., <a href="https://arxiv.org/abs/2501.04330">Sainsbury-Dale et al., 2025, Sec. 3.3</a>, and the references therein).</p><p>Approximately independent simulations can be obtained by setting  <code>nsims</code> &gt; 1 or <code>num_iterations &gt; burn</code>. The degree to which the  resulting simulations can be considered independent depends on the  thinning factor (<code>thin</code>) and the burn-in (<code>burn</code>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>nsims = 1</code>: number of approximately independent replicates. </li><li><code>num_iterations = 2000</code>: number of MCMC iterations.</li><li><code>burn = num_iterations</code>: burn-in.</li><li><code>thin = 10</code>: thinning factor.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators 

## Marginal simulation 
Œ≤ = 0.8
simulatepotts(10, 10, 5, Œ≤)

## Marginal simulation: approximately independent samples 
simulatepotts(10, 10, 5, Œ≤; nsims = 100, thin = 10)

## Conditional simulation 
Œ≤ = 0.8
complete_grid   = simulatepotts(50, 50, 2, Œ≤)        # simulate marginally from the Ising model 
incomplete_grid = removedata(complete_grid, 0.1)     # remove 10% of the pixels at random  
imputed_grid    = simulatepotts(incomplete_grid, Œ≤)  # conditionally simulate over missing pixels

## Multiple conditional simulations 
imputed_grids   = simulatepotts(incomplete_grid, Œ≤; num_iterations = 2000, burn = 1000, thin = 10)

## Recreate Fig. 8.8 of Marin &amp; Robert (2007) ‚ÄúBayesian Core‚Äù
using Plots 
grids = [simulatepotts(100, 100, 2, Œ≤) for Œ≤ ‚àà 0.3:0.1:1.2]
heatmaps = heatmap.(grids, legend = false, aspect_ratio=1)
Plots.plot(heatmaps...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/simulate.jl#L306-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.simulateschlather" href="#NeuralEstimators.simulateschlather"><code>NeuralEstimators.simulateschlather</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulateschlather(L::Matrix, m = 1; C = 3.5, Gumbel::Bool = false)</code></pre><p>Simulates <code>m</code> independent and identically distributed realisations from <a href="https://link.springer.com/article/10.1023/A:1020977924878">Schlather&#39;s (2002)</a> max-stable model given the lower Cholesky factor <code>L</code> of the covariance matrix of the underlying Gaussian process. </p><p>The function uses the algorithm for approximate simulation given by <a href="https://link.springer.com/article/10.1023/A:1020977924878">Schlather (2002)</a>.</p><p>If <code>m</code> is not specified, the simulated data are returned as a vector with length equal to the number of spatial locations, <span>$n$</span>; otherwise, the data are  returned as an <span>$n$</span>x<code>m</code> matrix.</p><p><strong>Keyword arguments</strong></p><ul><li><code>C = 3.5</code>: a tuning parameter that controls the accuracy of the algorithm. Small <code>C</code> favours computational efficiency, while large <code>C</code> favours accuracy. </li><li><code>Gumbel = true</code>: flag indicating whether the data should be log-transformed from the unit Fr√©chet scale to the Gumbel scale.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators, Distances, LinearAlgebra

n = 500
œÅ = 0.6
ŒΩ = 1.0
S = rand(n, 2)
D = pairwise(Euclidean(), S, dims = 1)
Œ£ = Symmetric(matern.(D, œÅ, ŒΩ))
L = cholesky(Œ£).L
simulateschlather(L)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/simulate.jl#L36-L65">source</a></section></article><h2 id="Spatial-point-processes"><a class="docs-heading-anchor" href="#Spatial-point-processes">Spatial point processes</a><a id="Spatial-point-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-point-processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.maternclusterprocess" href="#NeuralEstimators.maternclusterprocess"><code>NeuralEstimators.maternclusterprocess</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maternclusterprocess(; Œª=10, Œº=10, r=0.1, xmin=0, xmax=1, ymin=0, ymax=1, unit_bounding_box=false)</code></pre><p>Generates a realisation from a Mat√©rn cluster process (e.g., <a href="https://www.taylorfrancis.com/books/mono/10.1201/b19708/spatial-point-patterns-adrian-baddeley-rolf-turner-ege-rubak">Baddeley et al., 2015</a>, Ch. 12). </p><p>The process is defined by a parent homogenous Poisson point process with intensity <code>Œª</code> &gt; 0, a mean number of daughter points <code>Œº</code> &gt; 0, and a cluster radius <code>r</code> &gt; 0. The simulation is performed over a rectangular window defined by [<code>xmin, xmax</code>] √ó [<code>ymin</code>, <code>ymax</code>].</p><p>If <code>unit_bounding_box = true</code>, the simulated points will be scaled so that the longest side of their bounding box is equal to one (this may change the simulation window). </p><p>See also the R package <a href="https://cran.r-project.org/web/packages/spatstat/index.html"><code>spatstat</code></a>, which provides functions for simulating from a range of point processes and which can be interfaced from Julia using <a href="https://juliainterop.github.io/RCall.jl/stable/"><code>RCall</code></a>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators

# Simulate a realisation from a Mat√©rn cluster process
S = maternclusterprocess()

# Visualise realisation (requires UnicodePlots)
using UnicodePlots
scatterplot(S[:, 1], S[:, 2])

# Visualise realisations from the cluster process with varying parameters
n = 250
Œª = [10, 25, 50, 90]
Œº = n ./ Œª
plots = map(eachindex(Œª)) do i
	S = maternclusterprocess(Œª = Œª[i], Œº = Œº[i])
	scatterplot(S[:, 1], S[:, 2])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/Graphs.jl#L1052-L1087">source</a></section></article><h2 id="Covariance-functions"><a class="docs-heading-anchor" href="#Covariance-functions">Covariance functions</a><a id="Covariance-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-functions" title="Permalink"></a></h2><p>These covariance functions may be of use for various models.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.matern" href="#NeuralEstimators.matern"><code>NeuralEstimators.matern</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matern(h, œÅ, ŒΩ, œÉ¬≤ = 1)</code></pre><p>Given distance <span>$\|\boldsymbol{h}\|$</span> (<code>h</code>), computes the Mat√©rn covariance function</p><p class="math-container">\[C(\|\boldsymbol{h}\|) = \sigma^2 \frac{2^{1 - \nu}}{\Gamma(\nu)} \left(\frac{\|\boldsymbol{h}\|}{\rho}\right)^\nu K_\nu \left(\frac{\|\boldsymbol{h}\|}{\rho}\right),\]</p><p>where <code>œÅ</code> is a range parameter, <code>ŒΩ</code> is a smoothness parameter, <code>œÉ¬≤</code> is the marginal variance,  <span>$\Gamma(\cdot)$</span> is the gamma function, and <span>$K_\nu(\cdot)$</span> is the modified Bessel function of the second kind of order <span>$\nu$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/simulate.jl#L115-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.paciorek" href="#NeuralEstimators.paciorek"><code>NeuralEstimators.paciorek</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">paciorek(s, r, œâ‚ÇÅ, œâ‚ÇÇ, œÅ, Œ≤)</code></pre><p>Given spatial locations <code>s</code> and <code>r</code>, computes the nonstationary covariance function </p><p class="math-container">\[C(\boldsymbol{s}, \boldsymbol{r}) = 
|\boldsymbol{\Sigma}(\boldsymbol{s})|^{1/4}
|\boldsymbol{\Sigma}(\boldsymbol{r})|^{1/4}
\left|\frac{\boldsymbol{\Sigma}(\boldsymbol{s}) + \boldsymbol{\Sigma}(\boldsymbol{r})}{2}\right|^{-1/2}
C^0\big(\sqrt{Q(\boldsymbol{s}, \boldsymbol{r})}\big), \]</p><p>where <span>$C^0(h) = \exp\{-(h/\rho)^{3/2}\}$</span> for range parameter <span>$\rho &gt; 0$</span>,  the matrix <span>$\boldsymbol{\Sigma}(\boldsymbol{s}) = \exp(\beta\|\boldsymbol{s} - \boldsymbol{\omega}\|)\boldsymbol{I}$</span>  is a kernel matrix (<a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/env.785">Paciorek and Schervish, 2006</a>)  with scale parameter <span>$\beta &gt; 0$</span> and reference point <span>$\boldsymbol{\omega} \equiv (\omega_1, \omega_2)&#39; \in \mathbb{R}^2$</span>, and </p><p class="math-container">\[Q(\boldsymbol{s}, \boldsymbol{r}) = 
(\boldsymbol{s} - \boldsymbol{r})&#39;
\left(\frac{\boldsymbol{\Sigma}(\boldsymbol{s}) + \boldsymbol{\Sigma}(\boldsymbol{r})}{2}\right)^{-1}
(\boldsymbol{s} - \boldsymbol{r})\]</p><p>is the squared Mahalanobis distance between <span>$\boldsymbol{s}$</span> and <span>$\boldsymbol{r}$</span>. </p><p>Note that, in practical applications, the reference point <span>$\boldsymbol{\omega}$</span> is often taken to be an estimable parameter rather than fixed and known. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/simulate.jl#L146-L170">source</a></section></article><h2 id="Density-functions"><a class="docs-heading-anchor" href="#Density-functions">Density functions</a><a id="Density-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Density-functions" title="Permalink"></a></h2><p>Density functions are not needed in the workflow of <code>NeuralEstimators</code>. However, as part of a series of comparison studies between neural estimators and likelihood-based estimators given in various paper, we have developed the following functions for evaluating the density function for several popular distributions. We include these in <code>NeuralEstimators</code> to cater for the possibility that they may be of use in future comparison studies.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.gaussiandensity" href="#NeuralEstimators.gaussiandensity"><code>NeuralEstimators.gaussiandensity</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussiandensity(Z::V, L::LT) where {V &lt;: AbstractVector, LT &lt;: LowerTriangular}
gaussiandensity(Z::A, L::LT) where {A &lt;: AbstractArray, LT &lt;: LowerTriangular}
gaussiandensity(Z::A, Œ£::M) where {A &lt;: AbstractArray, M &lt;: AbstractMatrix}</code></pre><p>Efficiently computes the density function for <code>Z</code> ~ ùëÅ(0, <code>Œ£</code>), namely,  </p><p class="math-container">\[|2\pi\boldsymbol{\Sigma}|^{-1/2} \exp\{-\frac{1}{2}\boldsymbol{Z}^\top \boldsymbol{\Sigma}^{-1}\boldsymbol{Z}\},\]</p><p>for covariance matrix <code>Œ£</code>, and where <code>L</code> is lower Cholesky factor of <code>Œ£</code>.</p><p>The method <code>gaussiandensity(Z::A, L::LT)</code> assumes that the last dimension of <code>Z</code> contains independent and identically distributed replicates.</p><p>If <code>logdensity = true</code> (default), the log-density is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/densities.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.schlatherbivariatedensity" href="#NeuralEstimators.schlatherbivariatedensity"><code>NeuralEstimators.schlatherbivariatedensity</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schlatherbivariatedensity(z‚ÇÅ, z‚ÇÇ, œà‚ÇÅ‚ÇÇ; logdensity = true)</code></pre><p>The bivariate density function (see, e.g., <a href="https://www.tandfonline.com/doi/suppl/10.1080/00031305.2023.2249522?scroll=top">Sainsbury-Dale et al., 2024</a>, Sec. S6.2) for <a href="https://link.springer.com/article/10.1023/A:1020977924878">Schlather&#39;s (2002)</a> max-stable model, where <code>œà‚ÇÅ‚ÇÇ</code> denotes the spatial correlation function evaluated at the locations of observations <code>z‚ÇÅ</code> and <code>z‚ÇÇ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/d16e39b7986e1d8f3a21a9fab8235288758c1b0b/src/densities.jl#L41-L44">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../loss/">¬´ Loss functions</a><a class="docs-footer-nextpage" href="../utility/">Miscellaneous ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Saturday 26 April 2025 05:10">Saturday 26 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
