<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model-specific functions · NeuralEstimators.jl</title><meta name="title" content="Model-specific functions · NeuralEstimators.jl"/><meta property="og:title" content="Model-specific functions · NeuralEstimators.jl"/><meta property="twitter:title" content="Model-specific functions · NeuralEstimators.jl"/><meta name="description" content="Documentation for NeuralEstimators.jl."/><meta property="og:description" content="Documentation for NeuralEstimators.jl."/><meta property="twitter:description" content="Documentation for NeuralEstimators.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NeuralEstimators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NeuralEstimators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NeuralEstimators</a></li><li><a class="tocitem" href="../../framework/">Framework</a></li><li><span class="tocitem">Workflow</span><ul><li><a class="tocitem" href="../../workflow/overview/">Overview</a></li><li><a class="tocitem" href="../../workflow/examples/">Examples</a></li><li><a class="tocitem" href="../../workflow/advancedusage/">Advanced usage</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../core/">Core</a></li><li><a class="tocitem" href="../architectures/">Architectures and activations functions</a></li><li><a class="tocitem" href="../loss/">Loss functions</a></li><li class="is-active"><a class="tocitem" href>Model-specific functions</a><ul class="internal"><li><a class="tocitem" href="#Data-simulators"><span>Data simulators</span></a></li><li><a class="tocitem" href="#Spatial-point-processes"><span>Spatial point processes</span></a></li><li><a class="tocitem" href="#Low-level-functions"><span>Low-level functions</span></a></li><li><a class="tocitem" href="#Density-functions"><span>Density functions</span></a></li></ul></li><li><a class="tocitem" href="../utility/">Miscellaneous</a></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Model-specific functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model-specific functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/msainsburydale/NeuralEstimators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/main/docs/src/API/simulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-specific-functions"><a class="docs-heading-anchor" href="#Model-specific-functions">Model-specific functions</a><a id="Model-specific-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Model-specific-functions" title="Permalink"></a></h1><h2 id="Data-simulators"><a class="docs-heading-anchor" href="#Data-simulators">Data simulators</a><a id="Data-simulators-1"></a><a class="docs-heading-anchor-permalink" href="#Data-simulators" title="Permalink"></a></h2><p>The philosophy of <code>NeuralEstimators</code> is to cater for arbitrary statistical models by having the user define their statistical model implicitly through simulated data. However, the following functions have been included as they may be helpful to others, and their source code provide an example for how a user could formulate code for their own model. If you&#39;ve developed similar functions that you think may be helpful to others, please get in touch or make a pull request.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.simulategaussianprocess" href="#NeuralEstimators.simulategaussianprocess"><code>NeuralEstimators.simulategaussianprocess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulategaussianprocess(L::Matrix, m = 1)
simulategaussianprocess(grf::GaussianRandomField, m = 1)</code></pre><p>Simulates <code>m</code> independent and identically distributed (i.i.d.) realisations from a mean-zero Gaussian process.</p><p>Accepts either the lower Cholesky factor <code>L</code> associated with a Gaussian process or a <code>GaussianRandomField</code> object <code>grf</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators

n  = 500
S  = rand(n, 2)
ρ  = 0.6
ν  = 1.0

# Passing GaussianRandomField object:
using GaussianRandomFields
cov = CovarianceFunction(2, Matern(ρ, ν))
grf = GaussianRandomField(cov, Cholesky(), S)
simulategaussianprocess(grf)

# Passing Cholesky factors directly as matrices:
L = grf.data
simulategaussianprocess(L)

# Circulant embedding, which is fast but can on only be used on grids:
pts = 1.0:50.0
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, minpadding = 100)
simulategaussianprocess(grf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/bc4cd6d197344875bf0d98778e33884bc345f14f/src/simulate.jl#L50-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.simulateschlather" href="#NeuralEstimators.simulateschlather"><code>NeuralEstimators.simulateschlather</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulateschlather(L::Matrix, m = 1)
simulateschlather(grf::GaussianRandomField, m = 1)</code></pre><p>Simulates <code>m</code> independent and identically distributed (i.i.d.) realisations from Schlather&#39;s max-stable model using the algorithm for approximate simulation given by Schlather (2002), &quot;Models for stationary max-stable random fields&quot;, Extremes, 5:33-44.</p><p>Accepts either the lower Cholesky factor <code>L</code> associated with a Gaussian process or a <code>GaussianRandomField</code> object <code>grf</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>C = 3.5</code>: a tuning parameter that controls the accuracy of the algorithm: small <code>C</code> favours computational efficiency, while large <code>C</code> favours accuracy. Schlather (2002) recommends the use of <code>C = 3</code>.</li><li><code>Gumbel = true</code>: flag indicating whether the data should be log-transformed from the unit Fréchet scale to the <code>Gumbel</code> scale.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators

n  = 500
S  = rand(n, 2)
ρ  = 0.6
ν  = 1.0

# Passing GaussianRandomField object:
using GaussianRandomFields
cov = CovarianceFunction(2, Matern(ρ, ν))
grf = GaussianRandomField(cov, Cholesky(), S)
simulateschlather(grf)

# Passing Cholesky factors directly as matrices:
L = grf.data
simulateschlather(L)

# Circulant embedding, which is fast but can on only be used on grids:
pts = 1.0:50.0
grf = GaussianRandomField(cov, CirculantEmbedding(), pts, pts, minpadding = 100)
simulateschlather(grf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/bc4cd6d197344875bf0d98778e33884bc345f14f/src/simulate.jl#L102-L142">source</a></section></article><h2 id="Spatial-point-processes"><a class="docs-heading-anchor" href="#Spatial-point-processes">Spatial point processes</a><a id="Spatial-point-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-point-processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.maternclusterprocess" href="#NeuralEstimators.maternclusterprocess"><code>NeuralEstimators.maternclusterprocess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maternclusterprocess(; λ=10, μ=10, r=0.1, xmin=0, xmax=1, ymin=0, ymax=1)</code></pre><p>Simulates a Matérn cluster process with density of parent Poisson point process <code>λ</code>, mean number of daughter points <code>μ</code>, and radius of cluster disk <code>r</code>, over the simulation window defined by <code>{x/y}min</code> and <code>{x/y}max</code>.</p><p>Note that one may also use the R package spatstat using RCall.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators

# Simulate a realisation from a Matérn cluster process
S = maternclusterprocess()

# Visualise realisation (requires UnicodePlots)
using UnicodePlots
scatterplot(S[:, 1], S[:, 2])

# Visualise realisations from the cluster process with varying parameters
n = 250
λ = [10, 25, 50, 90]
μ = n ./ λ
plots = map(eachindex(λ)) do i
	S = maternclusterprocess(λ = λ[i], μ = μ[i])
	scatterplot(S[:, 1], S[:, 2])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/bc4cd6d197344875bf0d98778e33884bc345f14f/src/Graphs.jl#L3-L32">source</a></section></article><h2 id="Low-level-functions"><a class="docs-heading-anchor" href="#Low-level-functions">Low-level functions</a><a id="Low-level-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-functions" title="Permalink"></a></h2><p>These low-level functions may be of use for various models.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.matern" href="#NeuralEstimators.matern"><code>NeuralEstimators.matern</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matern(h, ρ, ν, σ² = 1)</code></pre><p>For two points separated by <code>h</code> units, compute the Matérn covariance function, with range parameter <code>ρ</code>, smoothness parameter <code>ν</code>, and marginal variance parameter <code>σ²</code>.</p><p>We use the parametrisation <span>$C(\|\mathbf{h}\|) = \sigma^2 \frac{2^{1 - \nu}}{\Gamma(\nu)} \left(\frac{\|\mathbf{h}\|}{\rho}\right)^\nu K_\nu \left(\frac{\|\mathbf{h}\|}{\rho}\right)$</span>, where <span>$\Gamma(\cdot)$</span> is the gamma function, and <span>$K_\nu(\cdot)$</span> is the modified Bessel function of the second kind of order <span>$\nu$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/bc4cd6d197344875bf0d98778e33884bc345f14f/src/simulate.jl#L197-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.maternchols" href="#NeuralEstimators.maternchols"><code>NeuralEstimators.maternchols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maternchols(D, ρ, ν, σ² = 1; stack = true)</code></pre><p>Given a distance matrix <code>D</code>, constructs the Cholesky factor of the covariance matrix under the Matérn covariance function with range parameter <code>ρ</code>, smoothness parameter <code>ν</code>, and marginal variance <code>σ²</code>.</p><p>Providing vectors of parameters will yield a three-dimensional array of Cholesky factors (note that the vectors must of the same length, but a mix of vectors and scalars is allowed). A vector of distance matrices <code>D</code> may also be provided.</p><p>If <code>stack = true</code>, the Cholesky factors will be &quot;stacked&quot; into a three-dimensional array (this is only possible if all distance matrices in <code>D</code> are the same size).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using NeuralEstimators
using LinearAlgebra: norm
n  = 10
S  = rand(n, 2)
D  = [norm(sᵢ - sⱼ) for sᵢ ∈ eachrow(S), sⱼ ∈ eachrow(S)]
ρ  = [0.6, 0.5]
ν  = [0.7, 1.2]
σ² = [0.2, 0.4]
maternchols(D, ρ, ν)
maternchols([D], ρ, ν)
maternchols(D, ρ, ν, σ²; stack = false)

S̃  = rand(n, 2)
D̃  = [norm(sᵢ - sⱼ) for sᵢ ∈ eachrow(S̃), sⱼ ∈ eachrow(S̃)]
maternchols([D, D̃], ρ, ν, σ²)
maternchols([D, D̃], ρ, ν, σ²; stack = false)

S̃  = rand(2n, 2)
D̃  = [norm(sᵢ - sⱼ) for sᵢ ∈ eachrow(S̃), sⱼ ∈ eachrow(S̃)]
maternchols([D, D̃], ρ, ν, σ²; stack = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/bc4cd6d197344875bf0d98778e33884bc345f14f/src/simulate.jl#L228-L265">source</a></section></article><h2 id="Density-functions"><a class="docs-heading-anchor" href="#Density-functions">Density functions</a><a id="Density-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Density-functions" title="Permalink"></a></h2><p>Density functions are not needed in the workflow of <code>NeuralEstimators</code>. However, as part of a series of comparison studies between neural estimators and likelihood-based estimators given in the manuscript, we have developed the following density functions, and we include them in <code>NeuralEstimators</code> to cater for the possibility that they may be of use in future comparison studies.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.gaussiandensity" href="#NeuralEstimators.gaussiandensity"><code>NeuralEstimators.gaussiandensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussiandensity(y::V, L; logdensity = true) where {V &lt;: AbstractVector{T}} where T
gaussiandensity(y::A, Σ; logdensity = true) where {A &lt;: AbstractArray{T, N}} where {T, N}</code></pre><p>Efficiently computes the density function for <code>y</code> ~ 𝑁(0, <code>Σ</code>), with <code>L</code> the lower Cholesky factor of the covariance matrix <code>Σ</code>.</p><p>The method <code>gaussiandensity(y::A, Σ)</code> assumes that the last dimension of <code>y</code> corresponds to the independent-replicates dimension, and it exploits the fact that we need to compute the Cholesky factor <code>L</code> for these independent replicates once only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/bc4cd6d197344875bf0d98778e33884bc345f14f/src/densities.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NeuralEstimators.schlatherbivariatedensity" href="#NeuralEstimators.schlatherbivariatedensity"><code>NeuralEstimators.schlatherbivariatedensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schlatherbivariatedensity(z₁, z₂, ψ; logdensity = true)</code></pre><p>The bivariate density function for Schlather&#39;s max-stable model, as given in Huser (2013, pg. 231–232).</p><p>Huser, R. (2013). Statistical Modeling and Inference for Spatio-Temporal Ex- tremes. PhD thesis, Swiss Federal Institute of Technology, Lausanne, Switzerland.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/msainsburydale/NeuralEstimators.jl/blob/bc4cd6d197344875bf0d98778e33884bc345f14f/src/densities.jl#L65-L72">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../loss/">« Loss functions</a><a class="docs-footer-nextpage" href="../utility/">Miscellaneous »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 10 December 2023 23:25">Sunday 10 December 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
